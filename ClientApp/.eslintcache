[{"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\registerServiceWorker.js":"1","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\About.tsx":"2","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\UtilitySection.tsx":"3","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\NavMenu.tsx":"4","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\ServerCard.tsx":"5","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\backend\\Error.ts":"6","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\CommandGroup.tsx":"7","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\ServerSettings.tsx":"8","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\backend\\Commands.ts":"9","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\backend\\ResponseGroup.ts":"10","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\Help.tsx":"11","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\App.tsx":"12","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\index.js":"13","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\backend\\User.ts":"14","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\Home.tsx":"15"},{"size":4121,"mtime":1598469222881,"results":"16","hashOfConfig":"17"},{"size":1972,"mtime":1600890796604,"results":"18","hashOfConfig":"17"},{"size":4595,"mtime":1603836239563,"results":"19","hashOfConfig":"17"},{"size":5583,"mtime":1604939364792,"results":"20","hashOfConfig":"17"},{"size":928,"mtime":1600269338525,"results":"21","hashOfConfig":"17"},{"size":3144,"mtime":1605388995255,"results":"22","hashOfConfig":"17"},{"size":10403,"mtime":1606154285745,"results":"23","hashOfConfig":"17"},{"size":23965,"mtime":1606154266316,"results":"24","hashOfConfig":"17"},{"size":11532,"mtime":1606158663081,"results":"25","hashOfConfig":"17"},{"size":13038,"mtime":1606158652034,"results":"26","hashOfConfig":"17"},{"size":3722,"mtime":1603839512990,"results":"27","hashOfConfig":"17"},{"size":2428,"mtime":1606155403247,"results":"28","hashOfConfig":"17"},{"size":687,"mtime":1600708760419,"results":"29","hashOfConfig":"17"},{"size":1894,"mtime":1600126773741,"results":"30","hashOfConfig":"17"},{"size":2132,"mtime":1603912529569,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"x0els6",{"filePath":"35","messages":"36","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"37","usedDeprecatedRules":"38"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"41","messages":"42","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"47","messages":"48","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":1,"source":"51"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\registerServiceWorker.js",[],["66","67"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\About.tsx",["68","69"],"﻿import React, { Component } from \"react\";\r\nimport \"../css/Home.css\";\r\n\r\nexport const AboutSection: React.FunctionComponent = () =>\r\n{\r\n    return (\r\n        <div className=\"textColor _aboutSection\">\r\n            <h3>About The Bot</h3>\r\n\r\n            <p className=\"_textIndent\">\r\n                Brokkoly Bot is a Discord bot made to make life slightly easier on your server. At its core it is a quote bot made for retrieval of random hot takes or memorable quotes from the server's past. Instead of finding a link that people ask for on a daily basis, just use !command and the bot will send the preset response with the link.\r\n            </p>\r\n            <p className=\"_textIndent\">\r\n                The bot is built in Python with a PostgreSQL backend. The hosting and automatic deployment is done on Heroku. Check out the bot's code <a href=\"https://github.com/Brokkoly/BrokkolyBot\">here.</a>\r\n            </p>\r\n            <h3>About This Website</h3>\r\n            <p className=\"_textIndent\">\r\n                This website came along because I needed a good way for users to see what commands the bot has for their server, and having users edit settings through a text interface is not a good experience.\r\n            </p>\r\n            <p className=\"_textIndent\">\r\n                This website's client is built using Typescript and React. The web server is built using Asp.Net Core, which provides the apis used by the client in addition to connecting to the same PostgreSQL database used by the bot. The website is hosted on Azure. Check out the website's code <a href=\"https://github.com/Brokkoly/BrokkolyBotFrontend\">here.</a>\r\n            </p>\r\n            <h3>Other Information</h3>\r\n            <p className=\"_textIndent\">\r\n                Having trouble with the bot or this website? Leave an issue on the appropriate github repository, or send me an email <a href=\"mailto:brokkolybot@gmail.com\">here.</a>\r\n            </p>\r\n\r\n\r\n        </div>\r\n\r\n    );\r\n}",["70","71"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\UtilitySection.tsx",["72","73"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\NavMenu.tsx",["74","75"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\ServerCard.tsx",["76"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\backend\\Error.ts",["77"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\CommandGroup.tsx",["78","79","80","81","82","83"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\ServerSettings.tsx",["84","85","86","87","88","89"],"﻿import React, { CSSProperties, useEffect, useState } from \"react\";\r\nimport { Next } from \"react-bootstrap/lib/Pagination\";\r\nimport { toast } from \"react-toastify\";\r\nimport { InputGroupText } from \"reactstrap\";\r\nimport { Commands, ICommand } from \"../backend/Commands\";\r\nimport { ErrorLevels, Errors } from \"../backend/Error\";\r\nimport { IResponseGroup, IResponseGroupList, IUpdateResponseGroupProps, IUpdateResponseProps, ResponseGroup, ResponseGroupList } from \"../backend/ResponseGroup\";\r\nimport { IChannel, IRole, IServer, IServerInfo, Servers } from \"../backend/Servers\";\r\nimport '../css/CommandRow.css';\r\nimport '../css/Settings.css';\r\nimport { Helpers } from \"../helpers\";\r\nimport { ResponseGroupListComponent } from \"./CommandGroup\";\r\nimport { CommandRow } from \"./CommandRow\";\r\nimport { IServerFunctions, LoadingMessage } from \"./ServerList\";\r\n\r\ninterface IServerSettingsProps\r\n{\r\n    token: string;\r\n    serverIndex: number;\r\n    server: IServer;\r\n    restrictedCommands: string[];\r\n    serverFunctions: IServerFunctions;\r\n\r\n}\r\ninterface IUpdateCommandProps\r\n{\r\n    index: number;\r\n    newCommandString?: string;\r\n    newEntryValue?: string;\r\n    newModOnly?: number;\r\n}\r\n\r\nexport interface ICommandRowFunctions\r\n{\r\n    updateCommand(args: IUpdateCommandProps): void;\r\n    cancelCommand(index: number): void;\r\n    deleteCommand(index: number): void;\r\n    acceptCommand(index: number, editCallback: Function): void;\r\n}\r\nexport interface IExpandGroupArgs\r\n{\r\n    expanded: boolean;\r\n    commands?: string[];\r\n    command?: string;\r\n}\r\n\r\nexport const ServerSettings: React.FunctionComponent<IServerSettingsProps> = ({\r\n    server,\r\n    token,\r\n    restrictedCommands,\r\n    serverFunctions,\r\n    serverIndex\r\n}) =>\r\n{\r\n    const [responseGroupList, setResponseGroupList] = useState<IResponseGroupList>(new ResponseGroupList({ responseGroups: new Array<ResponseGroup>() }));\r\n    const [originalGroups, setOriginalGroups] = useState<Map<number, IResponseGroup>>(new Map<number, IResponseGroup>());\r\n\r\n    const [serverRoles, setServerRoles] = useState<IRole[]>([]);\r\n    const [serverChannels, setServerChannels] = useState<IChannel[]>([]);\r\n    const [loading, setLoading] = useState(true);\r\n    const [nextTempId, setNextTempId] = useState(-2);\r\n\r\n    useEffect(\r\n        () =>\r\n        {\r\n            async function fetchData(serverId: string)\r\n            {\r\n                let newResponseGroupTask = Commands.fetchResponseGroups(serverId);\r\n                let getGuildInfoTask = Servers.getGuildInfo(token, serverId);\r\n\r\n                let newResponseGroupList = await newResponseGroupTask;\r\n                if (server.userCanManage) {\r\n                    let nextId = nextTempId;\r\n                    let nextRespId = nextTempId - 1;\r\n                    setNextTempId(nextTempId - 2);\r\n                    let newRespGroup = new ResponseGroup(nextId, \"\", [], true);\r\n                    newRespGroup.insertNewResponseAtEnd(nextRespId);\r\n                    newResponseGroupList.responseGroups.push(newRespGroup);//TODO: add a function to add a new group instead of manually pushing\r\n\r\n\r\n                }\r\n                setResponseGroupList(newResponseGroupList);\r\n                const serverInfo: IServerInfo = await getGuildInfoTask;\r\n                setServerRoles(serverInfo.roles);\r\n                setServerChannels(serverInfo.channels);\r\n                setLoading(false);\r\n            }\r\n            setLoading(true);\r\n            fetchData(server.serverId);\r\n\r\n        },\r\n        [server.serverId, server.userCanManage, token]\r\n    );\r\n\r\n    async function handleResponseGroupAccept(groupId: number)\r\n    {\r\n        let groupToAccept = responseGroupList.findResponseGroup(groupId);\r\n        if (groupToAccept === undefined) {\r\n            return;\r\n        }\r\n        if (groupToAccept.checkHighestErrorLevel() >= ErrorLevels.Critical) {\r\n            toast(\"Could not accept. Please fix validation errors and try again\");\r\n            return;\r\n        }\r\n\r\n        groupToAccept = groupToAccept.copy();\r\n\r\n        let newResponsesList = [...groupToAccept.responses];\r\n        let newResponses: ICommand[] = [];\r\n        let deletedResponseIds: number[] = [];\r\n        let editedResponses: ICommand[] = [];\r\n        groupToAccept.responses.forEach((resp, index) =>\r\n        {\r\n            if (resp.id < 0) {\r\n                //Created\r\n                if (resp.deleted || resp.response === \"\") {\r\n                    //don't keep it around;\r\n                    newResponsesList = newResponsesList.filter(obj => obj !== resp);\r\n                }\r\n                else {\r\n                    newResponses.push(\r\n                        {\r\n                            id: resp.id,\r\n                            serverId: server.serverId,\r\n                            commandString: groupToAccept!.command,\r\n                            entryValue: resp.response,\r\n                            modOnly: resp.modOnly,\r\n                            updated: resp.edited,\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n            else if (resp.deleted) {\r\n                deletedResponseIds.push(resp.id);\r\n            }\r\n            else if (resp.edited) {\r\n                editedResponses.push(\r\n                    {\r\n                        id: resp.id,\r\n                        serverId: server.serverId,\r\n                        commandString: groupToAccept!.command,\r\n                        entryValue: resp.response,\r\n                        modOnly: resp.modOnly,\r\n                        updated: resp.edited,\r\n                    }\r\n                );\r\n            }\r\n        });\r\n        let putTask = Commands.putNewCommands(token, newResponses);\r\n        let deleteTask = Commands.deleteCommands(token, deletedResponseIds);\r\n        let postTask = Commands.postCommands(token, editedResponses);\r\n\r\n        let newIdMap = await putTask;\r\n        let deletedMap = await deleteTask;\r\n        newIdMap.forEach((newId, oldId) =>\r\n        {\r\n            let respToEdit = newResponsesList.find(resp => resp.id === oldId);\r\n            if (respToEdit) {\r\n                respToEdit.id = newId;\r\n            }\r\n        });\r\n        newResponsesList = newResponsesList.filter(resp =>\r\n        {\r\n            return !(deletedMap.has(resp.id) && deletedMap.get(resp.id));\r\n        });\r\n        if (!(await postTask)) {\r\n\r\n        }\r\n        groupToAccept.responses = newResponsesList;\r\n        groupToAccept.setEditMode(false);\r\n        groupToAccept.originalCommand = groupToAccept.command;\r\n\r\n        setOriginalGroups(origGroups =>\r\n        {\r\n            let newOrigGroups = new Map(origGroups);\r\n            newOrigGroups.delete(groupToAccept!.id);\r\n            return newOrigGroups;\r\n        })\r\n\r\n        setResponseGroupList(rgl =>\r\n        {\r\n            let newRGL = rgl.copy();\r\n            let index = newRGL.findResponseGroupIndex(groupToAccept!.id);\r\n            newRGL.responseGroups[index] = groupToAccept!;\r\n            return newRGL;\r\n        });\r\n\r\n\r\n    }\r\n\r\n\r\n    async function handleResponseGroupUpdate(args: IUpdateResponseGroupProps)\r\n    {\r\n        let tempId = nextTempId;\r\n        setNextTempId(nextTempId - 3);\r\n        if (args.revert) {\r\n            if (originalGroups.has(args.id)) {\r\n                let original = originalGroups.get(args.id);\r\n                await setOriginalGroups(origGrp =>\r\n                {\r\n                    let newOrigGroups = new Map(origGrp);\r\n                    newOrigGroups.delete(args.id);\r\n                    return newOrigGroups;\r\n                });\r\n                setResponseGroupList(rgl =>\r\n                {\r\n                    let newRGL = rgl.copy();\r\n                    let groupToUpdate = newRGL.findResponseGroup(args.id);\r\n                    if (groupToUpdate) {\r\n                        let oldExpandStatus = groupToUpdate.expanded;\r\n                        groupToUpdate = original!;\r\n                        groupToUpdate.setExpanded(oldExpandStatus);\r\n                    }\r\n                    return newRGL;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            await setOriginalGroups(origGrp =>\r\n            {\r\n                if (!origGrp.has(args.id)) {\r\n                    //update original groups state\r\n                    let newOrigGroups = new Map(origGrp);\r\n                    let original = responseGroupList.findResponseGroup(args.id)?.copy();\r\n                    if (!original) {\r\n                        return origGrp;\r\n                    }\r\n                    newOrigGroups.set(args.id, original);\r\n                    return newOrigGroups;\r\n                }\r\n                else {\r\n                    return origGrp;\r\n                }\r\n            });\r\n            setResponseGroupList(rgl =>\r\n            {\r\n                let newRGL = rgl.copy();\r\n                newRGL.handleResponseGroupUpdate(args, tempId, server.userCanManage);\r\n                return newRGL;\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    async function handleResponseUpdate(args: IUpdateResponseProps)\r\n    {\r\n        let tempId = nextTempId;\r\n        setNextTempId(nti =>\r\n        {\r\n            return nti--;\r\n        });\r\n        await setOriginalGroups(origGrp =>\r\n        {\r\n            if (!origGrp.has(args.groupId)) {\r\n                //update original groups state\r\n                let newOrigGroups = new Map(origGrp);\r\n                let original = responseGroupList.findResponseGroup(args.groupId)?.copy();\r\n                if (!original) {\r\n                    return origGrp;\r\n                }\r\n                newOrigGroups.set(args.groupId, original);\r\n                return newOrigGroups;\r\n            }\r\n            else {\r\n                return origGrp;\r\n            }\r\n        });\r\n        setResponseGroupList(rgl =>\r\n        {\r\n            let newRGL = rgl.copy();\r\n            newRGL.handleResponseUpdate(args, tempId);\r\n            return newRGL;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sorts a list of ICommands. Returns the sorted list\r\n     * Sorts new unsaved commands at the bottom, by id.\r\n     * Saved commands are sorted alphabetically by commandString, then on their ids (aka creation time)\r\n     * @param list the list to sort\r\n     * @returns the sorted list.\r\n     */\r\n    function sortListOfResponseGroups(list: IResponseGroup[]): IResponseGroup[]\r\n    {\r\n        let newList = [...list];\r\n\r\n        newList.sort((a, b) =>\r\n        {\r\n\r\n            if (a.id < 0 && b.id >= 0) {\r\n                return 1;\r\n            } else if (b.id < 0 && a.id >= 0) {\r\n                return -1;\r\n            }\r\n            if (a.command === b.command) {\r\n                return a.id - b.id;\r\n            } else {\r\n                return a.originalCommand > b.originalCommand ? 1 : -1;\r\n            }\r\n        });\r\n        return newList;\r\n    }\r\n\r\n\r\n    function expandAllGroups(expanded: boolean)\r\n    {\r\n        setResponseGroupList(rgl =>\r\n        {\r\n            let newRGL = rgl.copy();\r\n            newRGL.expandAllGroups(expanded);\r\n            return newRGL;\r\n        });\r\n    }\r\n\r\n    function expandGroup(groupId: number, expanded: boolean)\r\n    {\r\n        setResponseGroupList(rgl =>\r\n        {\r\n            let newRGL = rgl.copy();\r\n            newRGL.responseGroups.forEach((grp) =>\r\n            {\r\n                let newRG = grp.copy();\r\n                if (newRG.id === groupId) {\r\n                    newRG.setExpanded(expanded);\r\n\r\n                }\r\n            });\r\n            return newRGL;\r\n        });\r\n    }\r\n\r\n    return (\r\n        <LoadingMessage loading={loading}>\r\n\r\n            <div className=\"_inputText\" style={{ maxWidth: \"900px\", justifyContent: \"center\" }}>\r\n                <h3>\r\n                    {server.name}\r\n                </h3>\r\n            </div>\r\n            <OtherSettingsForm\r\n                server={server}\r\n                serverIndex={serverIndex}\r\n                serverRoles={serverRoles}\r\n                serverChannels={serverChannels}\r\n                serverFunctions={serverFunctions}\r\n            />\r\n            <div className=\"betweenDiv20\" />\r\n\r\n            <ResponseGroupListComponent responseGroupList={responseGroupList}\r\n                commandPrefix={server.commandPrefix || \"!\"}\r\n                userCanEdit={server.userCanManage}\r\n                callbackFunctions={\r\n                    {\r\n                        expandGroup: expandGroup,\r\n                        expandAllGroups: expandAllGroups,\r\n                        handleResponseUpdate: handleResponseUpdate,\r\n                        handleResponseGroupUpdate: handleResponseGroupUpdate,\r\n                        handleResponseGroupAccept: handleResponseGroupAccept\r\n                    }\r\n                }\r\n            />\r\n\r\n\r\n        </LoadingMessage >\r\n    );\r\n};\r\n\r\n\r\nexport const OtherSettingsForm: React.FunctionComponent<{\r\n    server: IServer;\r\n    serverIndex: number;\r\n    serverFunctions: IServerFunctions;\r\n    serverRoles: IRole[];\r\n    serverChannels: IChannel[];\r\n}> = ({\r\n    server,\r\n    serverFunctions,\r\n    serverIndex,\r\n    serverRoles,\r\n    serverChannels,\r\n}) =>\r\n    {\r\n        const [hasBeenUpdated, setHasBeenUpdated] = useState(false);\r\n        const [secondsErrors, setSecondsErrors] = useState<Errors>(new Errors());\r\n        const [prefixErrors, setPrefixErrors] = useState<Errors>(new Errors());\r\n        const [disableAccept, setDisableAccept] = useState(false);\r\n\r\n        /**\r\n         * Handler for changes in the timeout's value\r\n         * @param event the form event that caused the change\r\n         */\r\n        function handleNumberChange(event: any)\r\n        {\r\n            let actualNumber = event.target.value;\r\n            if (isNaN(actualNumber)) {\r\n                actualNumber = Number(actualNumber.replace(/\\D/g, ''));\r\n            }\r\n            serverFunctions.handleServerChange({ index: serverIndex, newTimeoutValue: actualNumber });\r\n            setHasBeenUpdated(true);\r\n        }\r\n\r\n        /**\r\n         * Handler for a change in the botManagerRoleId\r\n         * @param event the form event that caused the change\r\n         */\r\n        function handleRoleChange(event: any)\r\n        {\r\n            serverFunctions.handleServerChange({ index: serverIndex, newBotManagerRoleId: event.target.value });\r\n            setHasBeenUpdated(true);\r\n        }\r\n        function handleTwitchLiveRoleChange(event: any)\r\n        {\r\n            serverFunctions.handleServerChange({ index: serverIndex, newTwitchLiveRoleId: event.target.value });\r\n            setHasBeenUpdated(true);\r\n        }\r\n\r\n        /**\r\n         * Handler for a change in the twitchChannel\r\n         * @param event the form event that caused the change\r\n         */\r\n        function handleTwitchChannelChange(event: any)\r\n        {\r\n            serverFunctions.handleServerChange({ index: serverIndex, newTwitchChannelId: event.target.value });\r\n            setHasBeenUpdated(true);\r\n        }\r\n        /**\r\n         * Handler for a change in the command prefix.\r\n         * @param event the form event that caused the change\r\n         */\r\n        function handlePrefixChange(event: any)\r\n        {\r\n            serverFunctions.handleServerChange({ index: serverIndex, newCommandPrefix: event.target.value });\r\n            setHasBeenUpdated(true);\r\n        }\r\n\r\n        useEffect(\r\n            () =>\r\n            {\r\n                if (!hasBeenUpdated) {\r\n                    setSecondsErrors(new Errors());\r\n                    return;\r\n                }\r\n                setSecondsErrors(secErr =>\r\n                {\r\n                    return Servers.checkTimeoutValidity(server.timeoutSeconds);\r\n                });\r\n            },\r\n            [server.timeoutSeconds, hasBeenUpdated]\r\n        );\r\n\r\n        useEffect(\r\n            () =>\r\n            {\r\n                if (secondsErrors.getHighestErrorLevel() >= ErrorLevels.Critical || prefixErrors.getHighestErrorLevel() >= ErrorLevels.Critical) {\r\n                    setDisableAccept(true);\r\n                } else {\r\n                    setDisableAccept(false);\r\n                }\r\n            },\r\n            [secondsErrors, prefixErrors]\r\n        );\r\n\r\n        useEffect(() => { }, [serverRoles]);\r\n\r\n        useEffect(() =>\r\n        {\r\n            if (!hasBeenUpdated) {\r\n                setPrefixErrors(new Errors());\r\n                return;\r\n            }\r\n            setPrefixErrors(preErr =>\r\n            {\r\n                let prefixErr = Servers.checkCommandPrefixValidity(server.commandPrefix);\r\n                return prefixErr;\r\n            });\r\n        }, [server.commandPrefix, hasBeenUpdated]\r\n        );\r\n\r\n        /**\r\n        * Handler for the cancel button. Tells the list to cancel changes to this command. Resets hasBeenUpdated\r\n        * @param event the button's event.\r\n        */\r\n        function handleCancel(event: any)\r\n        {\r\n            event.preventDefault();\r\n            serverFunctions.handleServerCancel(serverIndex);\r\n            setHasBeenUpdated(false);\r\n        }\r\n        /**\r\n        * Handler for the form's submit. Lets the list know to save this server's changes\r\n        * Resets hasBeenUpdated\r\n        * @param event need to prevent the default behavior\r\n        */\r\n        function handleAccept(event: any)\r\n        {\r\n            event.preventDefault();\r\n            serverFunctions.handleServerAccept(serverIndex);\r\n            setHasBeenUpdated(false);\r\n        }\r\n\r\n        function constructStyleFromNumber(color: number): CSSProperties | undefined\r\n        {\r\n            return { color: color.toString(16) };\r\n        }\r\n\r\n\r\n        return (\r\n            <div>\r\n                <form onSubmit={handleAccept}>\r\n                    <div className=\"flexColumn\" >\r\n                        <div className=\"flexRow\">\r\n                            <label className=\"_inputText\">\r\n                                Cooldown (s):\r\n                            <input type=\"text\" value={server.timeoutSeconds} title={secondsErrors.toErrorMessage()} className={\"_formInput _commandInput \" + secondsErrors.getCssForError()} onChange={handleNumberChange} disabled={!server.userCanManage} />\r\n                            </label>\r\n                        </div>\r\n                        {/*TODO: info hover icon that says what exactly these do*/}\r\n                        <div className=\"flexRow \">\r\n                            <label className=\"_labelText\">\r\n                                {\"Select the role that can manage the bot: \"}\r\n                                <select\r\n                                    className=\"_formInput _roleSelect\"\r\n                                    value={server.botManagerRoleId || \"\"}\r\n                                    onChange={handleRoleChange}\r\n                                    disabled={!server.userCanManage}\r\n                                >\r\n                                    <option className=\"_roleOption\" key={\"0\"} value={\"\"}>\r\n                                        None\r\n            </option>\r\n                                    {serverRoles.map((rle: IRole) => (\r\n                                        <option\r\n                                            className=\"_roleOption\"\r\n                                            style={constructStyleFromNumber(rle.color)}\r\n                                            key={rle.id}\r\n                                            value={rle.id}\r\n                                        >\r\n                                            {rle.name}\r\n                                        </option>\r\n                                    ))}\r\n                                </select>\r\n                            </label>\r\n                        </div>\r\n                        <div className=\"flexRow\">\r\n                            <label className=\"_inputText\">\r\n                                {\"Select the channel where twitch updates should be posted:  \"}\r\n                                <select\r\n                                    className=\"_formInput _roleSelect\"\r\n                                    value={server.twitchChannelId || \"\"}\r\n                                    onChange={handleTwitchChannelChange}\r\n                                    disabled={!server.userCanManage}\r\n                                >\r\n                                    <option className=\"_roleOption \" key={\"0\"} value={\"\"}>\r\n                                        None\r\n                                    </option>\r\n                                    {serverChannels.map((channel: IChannel) => (\r\n                                        <option\r\n                                            className=\"_roleOption\"\r\n                                            key={channel.id}\r\n                                            value={channel.id}\r\n                                        >\r\n                                            {channel.name}\r\n                                        </option>\r\n                                    ))}\r\n                                </select>\r\n                            </label>\r\n                        </div>\r\n                        <div className=\"flexRow \">\r\n                            <label className=\"_inputText\">\r\n                                {\"Select the role for users currently broadcasting on twitch: \"}\r\n                                <select\r\n                                    className=\"_formInput _roleSelect\"\r\n                                    value={server.twitchLiveRoleId || \"\"}\r\n                                    onChange={handleTwitchLiveRoleChange}\r\n                                    disabled={!server.userCanManage}\r\n                                >\r\n                                    <option className=\"_roleOption\" key={\"0\"} value={\"\"}>\r\n                                        None\r\n            </option>\r\n                                    {serverRoles.map((rle: IRole) => (\r\n                                        <option\r\n                                            className=\"_roleOption\"\r\n                                            style={constructStyleFromNumber(rle.color)}\r\n                                            key={rle.id}\r\n                                            value={rle.id}\r\n                                        >\r\n                                            {rle.name}\r\n                                        </option>\r\n                                    ))}\r\n                                </select>\r\n                            </label>\r\n                        </div>\r\n                        <div className=\"flexRow\">\r\n                            <label className=\"_inputText\">\r\n                                {\"Command Prefix: \"}\r\n                                <input type=\"text\" value={server.commandPrefix || \"\"} title={prefixErrors.toErrorMessage()} className={\"_formInput _commandInput \" + prefixErrors.getCssForError()} onChange={handlePrefixChange} disabled={!server.userCanManage} placeholder=\"!\" />\r\n\r\n                            </label>\r\n                        </div>\r\n                        <div className=\"flexRow\">\r\n\r\n                            <button\r\n                                onClick={handleCancel}\r\n                                className={\r\n                                    \"_formButton _cancelButton \" + Helpers.nodispIf(!hasBeenUpdated)\r\n                                }\r\n                            >Revert</button>\r\n                            <input\r\n                                type=\"submit\"\r\n                                value=\"Accept\"\r\n                                className={\r\n                                    \"_formButton _acceptButton \" + Helpers.nodispIf(!hasBeenUpdated)\r\n                                }\r\n                                disabled={disableAccept}\r\n                            />\r\n                        </div>\r\n                    </div>\r\n                </form>\r\n            </div >\r\n        );\r\n    };\r\n","C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\backend\\Commands.ts",["90"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\backend\\ResponseGroup.ts",["91"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\Help.tsx",["92","93"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\App.tsx",[],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\index.js",[],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\backend\\User.ts",["94"],"C:\\Users\\Brendan Krull\\source\\repos\\BrokkolyBotFrontend\\ClientApp\\src\\components\\Home.tsx",[],{"ruleId":"95","replacedBy":"96"},{"ruleId":"97","replacedBy":"98"},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"103"},{"ruleId":"104","severity":1,"message":"105","line":1,"column":17,"nodeType":"106","messageId":"107","endLine":1,"endColumn":26},{"ruleId":"95","replacedBy":"96"},{"ruleId":"97","replacedBy":"98"},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"108"},{"ruleId":"104","severity":1,"message":"109","line":20,"column":15,"nodeType":"106","messageId":"107","endLine":20,"endColumn":30},{"ruleId":"104","severity":1,"message":"110","line":20,"column":12,"nodeType":"106","messageId":"107","endLine":20,"endColumn":19},{"ruleId":"104","severity":1,"message":"111","line":20,"column":21,"nodeType":"106","messageId":"107","endLine":20,"endColumn":31},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"112"},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"113"},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"114"},{"ruleId":"104","severity":1,"message":"115","line":2,"column":10,"nodeType":"106","messageId":"107","endLine":2,"endColumn":18},{"ruleId":"104","severity":1,"message":"116","line":3,"column":10,"nodeType":"106","messageId":"107","endLine":3,"endColumn":18},{"ruleId":"104","severity":1,"message":"117","line":3,"column":20,"nodeType":"106","messageId":"107","endLine":3,"endColumn":28},{"ruleId":"104","severity":1,"message":"118","line":6,"column":10,"nodeType":"106","messageId":"107","endLine":6,"endColumn":30},{"ruleId":"104","severity":1,"message":"119","line":6,"column":32,"nodeType":"106","messageId":"107","endLine":6,"endColumn":48},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"120"},{"ruleId":"104","severity":1,"message":"121","line":2,"column":10,"nodeType":"106","messageId":"107","endLine":2,"endColumn":14},{"ruleId":"104","severity":1,"message":"122","line":4,"column":10,"nodeType":"106","messageId":"107","endLine":4,"endColumn":24},{"ruleId":"104","severity":1,"message":"123","line":13,"column":10,"nodeType":"106","messageId":"107","endLine":13,"endColumn":20},{"ruleId":"124","severity":1,"message":"125","line":92,"column":9,"nodeType":"126","endLine":92,"endColumn":55,"suggestions":"127"},{"ruleId":"104","severity":1,"message":"128","line":283,"column":14,"nodeType":"106","messageId":"107","endLine":283,"endColumn":38},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"129"},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"130"},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"131"},{"ruleId":"104","severity":1,"message":"105","line":1,"column":17,"nodeType":"106","messageId":"107","endLine":1,"endColumn":26},{"ruleId":"99","severity":1,"message":"100","line":1,"column":1,"nodeType":"101","messageId":"102","fix":"132"},"no-native-reassign",["133"],"no-negated-in-lhs",["134"],"unicode-bom","Unexpected Unicode BOM (Byte Order Mark).","Program","unexpected",{"range":"135","text":"136"},"@typescript-eslint/no-unused-vars","'Component' is defined but never used.","Identifier","unusedVar",{"range":"137","text":"136"},"'discordAuthLink' is assigned a value but never used.","'cookies' is assigned a value but never used.","'setCookies' is assigned a value but never used.",{"range":"138","text":"136"},{"range":"139","text":"136"},{"range":"140","text":"136"},"'useState' is defined but never used.","'Commands' is defined but never used.","'ICommand' is defined but never used.","'ICommandRowFunctions' is defined but never used.","'IExpandGroupArgs' is defined but never used.",{"range":"141","text":"136"},"'Next' is defined but never used.","'InputGroupText' is defined but never used.","'CommandRow' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'nextTempId'. Either include it or remove the dependency array. You can also do a functional update 'setNextTempId(n => ...)' if you only need 'nextTempId' in the 'setNextTempId' call.","ArrayExpression",["142"],"'sortListOfResponseGroups' is defined but never used.",{"range":"143","text":"136"},{"range":"144","text":"136"},{"range":"145","text":"136"},{"range":"146","text":"136"},"no-global-assign","no-unsafe-negation",[-1,0],"",[-1,0],[-1,0],[-1,0],[-1,0],[-1,0],{"desc":"147","fix":"148"},[-1,0],[-1,0],[-1,0],[-1,0],"Update the dependencies array to be: [nextTempId, server.serverId, server.userCanManage, token]",{"range":"149","text":"150"},[3507,3553],"[nextTempId, server.serverId, server.userCanManage, token]"]